import json

from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer
from datetime import datetime
from datetime import timezone

from django.core.cache import cache
from django.core.files.base import ContentFile

from project.storage_backend import ChatStorage


class ChatConsumer(WebsocketConsumer):
    def connect(self):
        profile = self.scope["user"].profile
        self.room_id = self.scope["url_route"]["kwargs"]["room_id"]
        self.room_group_name = f"chat_{self.room_id}"

        # Join room group
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name, self.channel_name
        )

        # Mark this user as active in this room
        cache.set(f"user_{profile.id}_active_room", self.room_id, timeout=0)

        from chat.models import RoomUnread
        # Remove any unread entry for this user + this room
        RoomUnread.objects.filter(profile=profile, room_id=self.room_id).delete()

        self.accept()

    def disconnect(self, close_code):
        profile = self.scope["user"].profile
        # Leave room group
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name, self.channel_name
        )

        # Mark user as not in this room anymore
        cache.delete(f"user_{profile.id}_active_room")

    # Receive message from WebSocket
    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json["message"]
        username = text_data_json["username"]
        room_id = text_data_json["room_id"]
        computing_id = text_data_json.get("computing_id", "")

        # Save message to S3
        save_message_to_s3(room_id, username, computing_id, message)

        # Add unread entry for all users not active in this room
        # Generated by GitHub Copilot
        from chat.models import ChatAccess
        access_entries = ChatAccess.objects.filter(room_id=room_id).select_related("user")
        for access in access_entries:
            add_unread_if_user_not_active(access.user, room_id)

        # Send message to room group
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name, {"type": "chat.message",
                                   "message": message,
                                   "username": username,
                                   "computing_id": computing_id}
        )

    # Receive message from room group
    def chat_message(self, event):
        message = event["message"]
        username = event["username"]
        computing_id = event["computing_id"]

        # Send message to WebSocket
        self.send(text_data=json.dumps({"message": message, "username": username, "computing_id": computing_id}))

def save_message_to_s3(room: int, username, computing_id, message):
    storage = ChatStorage()

    data = {
        "room": room,
        "username": username,
        "computing_id": computing_id,
        "message": message,
        "timestamp": datetime.now(timezone.utc).isoformat() + "Z",
    }

    filename = f"{str(room)}/{datetime.now(timezone.utc).timestamp()}.json"
    content = ContentFile(json.dumps(data).encode("utf-8"))

    path = storage.save(filename, content)
    return path

def add_unread_if_user_not_active(profile, room_id):
    active_room = cache.get(f"user_{profile.id}_active_room")

    if str(active_room) == str(room_id):
        return
    from chat.models import RoomUnread
    # Otherwise create an unread entry
    RoomUnread.objects.get_or_create(profile=profile, room_id=room_id)